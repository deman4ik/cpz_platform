import ServiceError from "cpz/error";
import dayjs from "cpz/utils/dayjs";
import { v4 as uuid } from "uuid";
import {
  CANDLE_CREATED,
  CANDLE_IMPORTED,
  CANDLE_PREVIOUS,
  createCachedCandleSlug,
  createImporterSlug,
  STATUS_ERROR,
  STATUS_FINISHED,
  STATUS_STARTED,
  VALID_TIMEFRAMES
} from "cpz/config/state";
import Log from "cpz/log";
import EventGrid from "cpz/events";
import {
  chunkArray,
  completedPercent,
  divideDateByDays,
  durationMinutes,
  sortAsc
} from "cpz/utils/helpers";
import { saveCandlesArrayToCache } from "cpz/tableStorage-client/market/candles";
import { saveImporterState } from "cpz/tableStorage-client/control/importers";
import { saveCandlesDB } from "cpz/db-client/candles";
import { minuteCandlesEX } from "cpz/connector-client/candles";
import { tradesEX } from "cpz/connector-client/trades";
import {
  chunkDates,
  createMinutesList,
  createMinutesListWithRange,
  generateCandleRowKey,
  getCurrentTimeframes,
  handleCandleGaps
} from "cpz/utils/candlesUtils";
import {
  TASKS_IMPORTER_FINISHED_EVENT,
  TASKS_IMPORTER_STARTED_EVENT
} from "cpz/events/types/tasks/importer";
import { ERROR_IMPORTER_ERROR_EVENT } from "cpz/events/types/error";
import { combineImporterSettings } from "cpz/utils/settings";

/* Types descriptions */

/**
 * An InputCandles Array
 *
 * @typedef {Object[]} InputCandles
 * @param  {string} InputCandles[].id - id generated by uuid()
 * @param  {string} InputCandles[].PartitionKey
 * @param  {string} InputCandles[].RowKey - inverted_timestamp
 * @param  {string} InputCandles[].taskId - id generated by uuid()
 * @param  {string} InputCandles[].type - one of imported/created/previous
 * @param  {string} InputCandles[].exchange - Exchange name
 * @param  {string} InputCandles[].asset - asset
 * @param  {string} InputCandles[].currency - currency
 * @param  {number} InputCandles[].timeframe - one of possible timeframes
 * @param  {number} InputCandles[].time - in milliseconds
 * @param  {date}   InputCandles[].timestamp - ISO String of Date
 * @param  {number} InputCandles[].open - open price
 * @param  {number} InputCandles[].high - high price
 * @param  {number} InputCandles[].low - low price
 * @param  {number} InputCandles[].close - close price
 * @param  {number} InputCandles[].volume - trades volume
 * @example
 * [{
      id: "a44c1258-cadc-48b8-992c-e0315662e598",
      PartitionKey: "bitfinex.BTC.USD"
      RowKey: "000000003460000",
      taskId: f5db5753-1989-4f48-901b-e92e962322ac,
      type: ‘imported,
      exchange: ‘bitfinex’,
      asset: “BTC”,
      currency: “USD”,
      timeframe: 1,
      time: 1550749781000,
      timestamp: "2019-02-21T11:49:41.000Z",
      open: 3500,
      high: 3700,
      low: 3303,
      close: 3459,
      volume: 235253,
    }]
 * */

/** @class Importer  */
class Importer {
  constructor(state) {
    /* Уникальный идентификатор задачи */
    this._taskId = state.taskId;
    /* Код биржи */
    this._exchange = state.exchange;
    /* Базовая валюта */
    this._asset = state.asset;
    /* Котировка валюты */
    this._currency = state.currency;
    this._PartitionKey =
      state.PartitionKey ||
      createImporterSlug({
        exchange: this._exchange,
        asset: this._asset,
        currency: this._currency
      });
    /* Генерируемые таймфреймы [1, 5, 15, 30, 60, 120, 240, 1440] */
    this._timeframes = state.timeframes || VALID_TIMEFRAMES;
    this._mode = state.mode;
    const { debug, importCandles } = combineImporterSettings(state.settings);
    this._settings = {
      debug,
      ...importCandles
    };
    /* Адрес прокси сервера */
    this._proxy = this._settings.proxy || process.env.PROXY_ENDPOINT;
    this._dateFrom = this._settings.dateFrom;
    this._dateTo = this._settings.dateTo;
    /* Лимит загружаемых свечей */
    this._limit = this.getLimit();
    this._loadDurationChunks = chunkDates(
      this._dateFrom,
      this._dateTo,
      this._limit
    );
    /* Всего свечей для загрузки */
    this._loadTotalDuration = this._loadDurationChunks.total;
    /* Загружено свечей */
    this._loadCompletedDuration = 0;
    /* Осталось загрузить свечей */
    this._loadLeftDuration = this._loadTotalDuration;
    /* Процент выполнения */
    this._loadPercent = 0;
    this._loadedCount = 0;
    this._gaps = 0;
    /* Всего свечей для загрузки */
    this._processTotalDuration = this._loadTotalDuration;
    /* Загружено свечей */
    this._processCompletedDuration = 0;
    /* Осталось загрузить свечей */
    this._processLeftDuration = this._processTotalDuration;
    /* Процент выполнения */
    this._processPercent = 0;

    /* Текущий статус сервиса */
    this._status = STATUS_STARTED;
    /* Дата и время запуска */
    this._startedAt = dayjs.utc().toISOString();
    /* Дата и время остановки */
    this._endedAt = null;
    /* Метаданные стореджа */
    this._metadata = state.metadata;
    this._candles = [];
  }

  get props() {
    return {
      taskId: this._taskId,
      exchange: this._exchange,
      asset: this._asset,
      currency: this._currency,
      dateFrom: this._dateFrom,
      dateTo: this._dateTo
    };
  }

  /**
   * Объединяем исходные и пропущенные свечи в один массив
   * @method
   * @param {Array} candles - Исходный массив свечей
   * @param {Array} gappedCandles - Массив пропущенных свечей
   * @returns {Array} - Отсортированный по времени объединенный массив candles и gappedCandles
   * @example
   * combineCandles([
   {
        id: "a44c1258-cadc-48b8-992c-e0315662e598",
        PartitionKey: "bitfinex.BTC.USD",
        RowKey: "000000003460000",
        taskId: "f5db5753-1989-4f48-901b-e92e962322ac",
        type: "previous",
        exchange: "bitfinex",
        asset: "BTC",
        currency: "USD",
        timeframe: 1,
        time: 1550748960000,
        timestamp: "2019-02-21T11:36:00.000Z",
        open: 3500,
        high: 3700,
        low: 3303,
        close: 3459,
        volume: 235253
      },
   {
        id: "a44c1258-cadc-48b8-992c-e0315662e548",
        PartitionKey: "bitfinex.BTC.USD",
        RowKey: "000000003460000",
        taskId: "f5db5753-1989-4f48-901b-e92e965322ac",
        type: "previous",
        exchange: "bitfinex",
        asset: "BTC",
        currency: "USD",
        timeframe: 1,
        time: 1550749140000,
        timestamp: "2019-02-21T11:39:00.000Z",
        open: 300,
        high: 3700,
        low: 3303,
        close: 3459,
        volume: 235253
      }
   ], [{
        id: "a44c1258-cadc-48b8-992c-e0315662e548",
        PartitionKey: "bitfinex.BTC.USD",
        RowKey: "000000003460000",
        taskId: "f5db5753-1989-4f48-901b-e92e965322ac",
        type: "previous",
        exchange: "bitfinex",
        asset: "BTC",
        currency: "USD",
        timeframe: 1,
        time: 1550749380000,
        timestamp: "2019-02-21T11:43:00.000Z",
        open: 300,
        high: 3700,
        low: 3303,
        close: 3459,
        volume: 235253
      },])
   // return [
          {
            id: "a44c1258-cadc-48b8-992c-e0315662e598",
            PartitionKey: "bitfinex.BTC.USD",
            RowKey: "000000003460000",
            taskId: "f5db5753-1989-4f48-901b-e92e962322ac",
            type: "previous",
            exchange: "bitfinex",
            asset: "BTC",
            currency: "USD",
            timeframe: 1,
            time: 1550748960000,
            timestamp: "2019-02-21T11:36:00.000Z",
            open: 3500,
            high: 3700,
            low: 3303,
            close: 3459,
            volume: 235253
          }
        ]
   * */
  // TODO Добавить тест
  combineCandles(candles, gappedCandles) {
    return [...new Set(candles.concat(gappedCandles))].sort((a, b) =>
      sortAsc(a.time, b.time)
    );
  }

  /**
   * Логирование в консоль, Importer#log
   *
   * @param  {*} args
   * @inner
   * @memberof Importer
   */
  log(...args) {
    if (this._settings.debug) {
      Log.debug(`Importer ${this._PartitionKey}:`, ...args);
    }
  }

  logInfo(...args) {
    Log.info(`Importer ${this._PartitionKey}:`, ...args);
  }

  getLimit() {
    switch (this._exchange) {
      case "bitfinex":
        return 1000;
      case "kraken":
        return 500;
      case "coinbasepro":
        return 300;
      default:
        return 500;
    }
  }

  createCandles(trades, dateFrom, dateTo) {
    this.log(
      "createCandles from trades",
      dayjs.utc(dateFrom).toISOString(),
      dayjs.utc(dateTo).toISOString()
    );
    const candles = [];
    const minutes = createMinutesListWithRange(dateFrom, dateTo);
    minutes.forEach(minute => {
      const minuteTrades = [
        ...new Set(
          trades.filter(
            trade =>
              trade.time >= dayjs.utc(minute.dateFrom).valueOf() &&
              trade.time <= dayjs.utc(minute.dateTo).valueOf()
          )
        )
      ].sort((a, b) => sortAsc(a.time, b.time));

      if (minuteTrades && minuteTrades.length > 0) {
        candles.push({
          PartitionKey: createCachedCandleSlug({
            exchange: this._exchange,
            asset: this._asset,
            currency: this._currency,
            timeframe: 1
          }),
          RowKey: generateCandleRowKey(minute.dateFrom),
          id: uuid(),
          taskId: this._taskId,
          exchange: this._exchange,
          asset: this._asset,
          currency: this._currency,
          timeframe: 1,
          time: +minute.dateFrom, // время в милисекундах
          timestamp: dayjs.utc(minute.dateFrom).toISOString(), // время в ISO UTC
          open: +minuteTrades[0].price, // цена открытия - цена первого тика
          high: +Math.max(...minuteTrades.map(t => +t.price)), // максимальная цена тиков
          low: +Math.min(...minuteTrades.map(t => +t.price)), // минимальная цена тиков
          close: +minuteTrades[minuteTrades.length - 1].price, // цена закрытия - цена последнего тика
          volume: +minuteTrades.map(t => t.amount).reduce((a, b) => a + b), // объем - сумма объема всех тиков
          type: CANDLE_CREATED // признак - свеча сформирована
        });
      }
    });

    return candles;
  }

  async loadTradesAndMakeCandles({ dateFrom, dateTo, duration }) {
    try {
      this.log(
        "loadTradesAndMakeCandles",
        dayjs.utc(dateFrom).toISOString(),
        dayjs.utc(dateTo).toISOString()
      );
      let trades = [];
      let dateNext = dateFrom;
      while (dayjs.utc(dateNext).valueOf() < dayjs.utc(dateTo).valueOf()) {
        // eslint-disable-next-line no-await-in-loop
        const response = await tradesEX({
          proxy: this._proxy,
          exchange: this._exchange,
          asset: this._asset,
          currency: this._currency,
          date: dayjs.utc(dateNext).toISOString()
        });
        dateNext =
          (response.length > 0 && response[response.length - 1].timestamp) ||
          dateTo;
        const filteredData = [
          ...new Set(
            response.filter(
              trade =>
                trade.time >= dayjs.utc(dateFrom).valueOf() &&
                trade.time <= dayjs.utc(dateTo).valueOf()
            )
          )
        ].sort((a, b) => sortAsc(a.time, b.time));

        trades = [...new Set(trades.concat(filteredData))].sort((a, b) =>
          sortAsc(a.time, b.time)
        );
      }

      const candles = this.createCandles(trades, dateFrom, dateTo);

      return {
        success: true,
        dateFrom,
        dateTo,
        duration,
        count: candles.length,
        data: candles
      };
    } catch (error) {
      Log.error(error.message);
      return {
        success: false,
        date: dateFrom,
        duration,
        count: 0,
        error
      };
    }
  }

  async loadCandles({ dateFrom, dateTo, duration }) {
    try {
      this.log(
        "loadAndSaveCandles",
        dayjs.utc(dateFrom).toISOString(),
        dayjs.utc(dateTo).toISOString()
      );
      /* Если биржа "kraken" и грузим больше чем за последние 10 часов  */
      if (
        this._exchange === "kraken" &&
        dayjs.utc().diff(dayjs.utc(dateFrom), "hours") > 10
      ) {
        /* Собираем минутные свечи по трейдам */
        return await this.loadTradesAndMakeCandles({
          dateFrom,
          dateTo,
          duration
        });
      }
      const response = await minuteCandlesEX({
        proxy: this._proxy,
        exchange: this._exchange,
        asset: this._asset,
        currency: this._currency,
        date: dayjs.utc(dateFrom).toISOString(),
        limit: duration
      });
      if (response && response.length > 0) {
        const filteredData = [
          ...new Set(
            response.filter(
              candle =>
                candle.time >= dayjs.utc(dateFrom).valueOf() &&
                candle.time <= dayjs.utc(dateTo).valueOf()
            )
          )
        ].sort((a, b) => sortAsc(a.time, b.time));
        if (filteredData && filteredData.length > 0) {
          const data = filteredData.map(candle => ({
            ...candle,
            id: uuid(),
            PartitionKey: createCachedCandleSlug({
              exchange: this._exchange,
              asset: this._asset,
              currency: this._currency,
              timeframe: 1
            }),
            RowKey: generateCandleRowKey(candle.time),
            taskId: this._taskId,
            type: CANDLE_IMPORTED
          }));
          if (data)
            return {
              success: true,
              dateFrom,
              dateTo,
              duration,
              count: data.length,
              data
            };
        }
      }
      this.log("Empty response");
      return {
        success: false,
        dateFrom,
        dateTo,
        duration,
        count: 0,
        error: "Empty response"
      };
    } catch (error) {
      Log.error(error.message);
      return {
        success: false,
        date: dateFrom,
        duration,
        count: 0,
        error
      };
    }
  }

  /**
   * Проверка пропусков
   *
   * @param {InputCandles} InputCandles
   * @param {string} dateFrom
   * @param {string} dateTo
   * @returns {Object}
   */
  async handleGaps(InputCandles, dateFrom, dateTo) {
    try {
      let candles = [...InputCandles];
      const duration = durationMinutes(dateFrom, dateTo);
      // Если количество свечей в кэше равно общему количеству свечей - нет пропусков
      if (candles.length === duration) return { candles, gappedCandles: [] };

      const gappedCandles = handleCandleGaps(
        {
          exchange: this._exchange,
          asset: this._asset,
          currency: this._currency,
          timeframe: 1,
          taskId: this._taskId
        },
        dateFrom,
        dateTo,
        duration,
        candles
      );
      if (gappedCandles.length > 0) {
        candles = this.combineCandles(candles, gappedCandles);
      }
      return { candles, gappedCandles };
    } catch (e) {
      throw new ServiceError(
        {
          name: ServiceError.tasks.IMPORTER_HANDLE_GAPS_ERROR,
          cause: e,
          info: {
            ...this.props
          }
        },
        `Failed to check cached candles gaps`
      );
    }
  }

  /**
   * Свертывание загруженных свечей
   *
   * @memberof Importer
   */
  batchCandles(tempCandles, dateFrom, dateTo, duration) {
    try {
      this.log("batchCandles", dateFrom, dateTo);
      // Инициализируем объект со свечами в различных таймфреймах
      const timeframeCandles = {};
      this._timeframes.forEach(timeframe => {
        timeframeCandles[timeframe] = [];
        if (timeframe === 1) {
          timeframeCandles[1] = [...tempCandles];
        }
      });
      // Если не нужно свертывать свечи - выходим
      if (!this._settings.requireBatching) return null;
      // Создаем список с полным количеством минут
      const fullMinutesList = createMinutesList(dateFrom, dateTo, duration + 1); // добавляем еще одну свечу чтобы сформировать прошедший таймфрейм
      fullMinutesList.forEach(time => {
        const date = dayjs.utc(time);
        // Пропускаем самую первую свечу
        if (dayjs.utc(dateFrom).valueOf() === date.valueOf()) return;
        const currentTimeframes = getCurrentTimeframes(this._timeframes, time);
        if (currentTimeframes.length > 0) {
          currentTimeframes.forEach(timeframe => {
            const timeFrom = date.add(-timeframe, "minute").valueOf();
            const timeTo = date.valueOf();
            const candles = tempCandles
              .filter(candle => candle.time >= timeFrom && candle.time < timeTo)
              .sort((a, b) => sortAsc(a.time, b.time));
            if (candles.length > 0) {
              timeframeCandles[timeframe].push({
                id: uuid(),
                PartitionKey: createCachedCandleSlug({
                  exchange: this._exchange,
                  asset: this._asset,
                  currency: this._currency,
                  timeframe
                }),
                RowKey: generateCandleRowKey(timeFrom),
                taskId: this._taskId,
                exchange: this._exchange,
                asset: this._asset,
                currency: this._currency,
                timeframe,
                time: timeFrom, // время в милисекундах
                timestamp: dayjs.utc(timeFrom).toISOString(), // время в ISO UTC
                open: +candles[0].open, // цена открытия - цена открытия первой свечи
                high: Math.max(...candles.map(t => +t.high)), // максимальная цена
                low: Math.min(...candles.map(t => +t.low)), // минимальная цена
                close: +candles[candles.length - 1].close, // цена закрытия - цена закрытия последней свечи
                volume: +candles.map(t => t.volume).reduce((a, b) => a + b), // объем - сумма объема всех свечей
                count: +candles.length,
                gap: candles.length !== timeframe,
                type:
                  candles.filter(candle => candle.type === CANDLE_PREVIOUS)
                    .length === timeframe
                    ? CANDLE_PREVIOUS
                    : CANDLE_CREATED
              });
            }
          });
        }
      });
      return timeframeCandles;
    } catch (error) {
      throw new ServiceError(
        {
          name: ServiceError.types.IMPORTER_BATCH_CANDLES_ERROR,
          cause: error,
          info: {
            ...this.props
          }
        },
        `Failed to batch cached candles`
      );
    }
  }

  /**
   * Сохранение свечей в кэш
   *
   * @memberof Importer
   * @param {Object} timeframeCandles - объект тайфреймов в формате ({“1”: [],“5”: []})
   */
  async saveCandles(timeframeCandles) {
    try {
      await Promise.all(
        this._timeframes.map(async timeframe => {
          if (timeframeCandles[timeframe].length > 0) {
            if (this._settings.saveToCache)
              await saveCandlesArrayToCache(timeframeCandles[timeframe]);
            await saveCandlesDB({
              timeframe,
              candles: timeframeCandles[timeframe]
            });
          }
        })
      );
    } catch (error) {
      throw new ServiceError(
        {
          name: ServiceError.types.IMPORTER_SAVE_CANDLES_ERROR,
          cause: error,
          info: {
            ...this.props
          }
        },
        `Failed to save candles`
      );
    }
  }

  /**
   * Очистка временных свечей
   *
   * @memberof Importer
   */
  /* async clearTemp() {
    try {
      this.log("Clearing temp data...");
      await clearTempCandles(this._taskId);
    } catch (error) {
      throw new ServiceError(
        {
          name: ServiceError.types.IMPORTER_CLEAR_TEMP_ERROR,
          cause: error,
          info: {
            ...this.props
          }
        },
        `Failed to clear temp candles`
      );
    }
  } */

  async execute() {
    try {
      await EventGrid.publish(TASKS_IMPORTER_STARTED_EVENT, {
        subject: this._taskId,
        data: {
          taskId: this._taskId
        }
      });

      const loadChunks = chunkArray(this._loadDurationChunks.chunks, 10);
      /* eslint-disable no-restricted-syntax, no-await-in-loop */
      this.log("Starting loading candles...");
      for (const loadChunk of loadChunks) {
        const loadIterationResult = await Promise.all(
          loadChunk.map(async ({ dateFrom, dateTo, duration }) =>
            this.loadCandles({ dateFrom, dateTo, duration })
          )
        );

        const errorLoads = loadIterationResult.filter(
          result => result.success === false
        );

        const retryLoadIterationResult = await Promise.all(
          errorLoads.map(async ({ dateFrom, dateTo, duration }) =>
            this.loadCandles({ dateFrom, dateTo, duration })
          )
        );

        const retryErrorLoads = retryLoadIterationResult.filter(
          result => result.success === false
        );

        if (retryErrorLoads.length > 0) {
          throw new ServiceError(
            {
              name: ServiceError.types.IMPORTER_LOAD_CANDLES_ERROR,
              info: {
                ...this.props,
                errorIterations: retryErrorLoads.map(errorLoad => ({
                  dateFrom: errorLoad.dateFrom,
                  dateTo: errorLoad.dateTo,
                  duration: errorLoad.duration
                }))
              }
            },
            "Failed to load chunk of candles"
          );
        }

        const successLoads = [
          ...loadIterationResult.filter(result => result.success === true),
          ...retryLoadIterationResult.filter(result => result.success === true)
        ];

        const duration = successLoads
          .map(load => load.duration)
          .reduce((acc, curr) => acc + curr);
        const loaded = successLoads
          .map(load => load.count)
          .reduce((acc, curr) => acc + curr);
        const data = successLoads
          .map(load => load.data)
          .reduce((acc, curr) => acc.concat(curr), []);
        this._candles = [...new Set(this._candles.concat(data))].sort((a, b) =>
          sortAsc(a.time, b.time)
        );
        this._loadCompletedDuration = this._loadCompletedDuration + duration;
        this._loadLeftDuration =
          this._loadTotalDuration - this._loadCompletedDuration;

        // Процент выполнения
        this._loadPercent = completedPercent(
          this._loadCompletedDuration,
          this._loadTotalDuration
        );
        this._loadedCount = this._loadedCount + loaded;
        let gaps = 0;
        if (loaded < duration) {
          gaps = duration - loaded;
        }
        this._gaps = this._gaps + gaps;
        await this.save();
        this.log(
          `Loaded ${this._loadCompletedDuration} of ${
            this._loadTotalDuration
          } - ${this._loadPercent}%${gaps > 0 ? ` but gapped: ${gaps}` : ""} `
        );
      }
      /*  no-restricted-syntax, no-await-in-loop */

      const fullDays = divideDateByDays(this._dateFrom, this._dateTo);
      this.log("Starting processing loaded candles...");
      for (const { dateFrom, dateTo, duration } of fullDays) {
        let tempCandles = this._candles.filter(
          candle =>
            candle.time >= dayjs.utc(dateFrom).valueOf() &&
            candle.time < dayjs.utc(dateTo).valueOf()
        );
        /*
        await getTempCandles({
          dateFrom,
          dateTo,
          slug: createCachedCandleSlug({
            exchange: this._exchange,
            asset: this._asset,
            currency: this._currency,
            timeframe: 1
          })
        }); */
        tempCandles = tempCandles.sort((a, b) => sortAsc(a.time, b.time));

        const { candles } = await this.handleGaps(
          tempCandles,
          dateFrom,
          dateTo
        );

        /*
        if (gappedCandles.length > 0) {
          // Сохраняем сформированные пропущенные свечи
          await saveCandlesArrayToTemp(gappedCandles);
        } */

        const timeframeCandles = this.batchCandles(
          candles,
          dateFrom,
          dateTo,
          duration
        );

        if (timeframeCandles) {
          await this.saveCandles(timeframeCandles);
        }

        this._processCompletedDuration =
          this._processCompletedDuration + duration;
        this._processLeftDuration =
          this._processTotalDuration - this._processCompletedDuration;

        this._processPercent = completedPercent(
          this._processCompletedDuration,
          this._processTotalDuration
        );
        await this.save();
        this.log(
          `Processed ${this._processCompletedDuration} of ${
            this._processTotalDuration
          } - ${this._processPercent}%`
        );
      }

      // await this.clearTemp();
      this._endedAt = dayjs.utc().toISOString();
      this._status = STATUS_FINISHED;

      await this.save();
      const duration = dayjs
        .utc(this._endedAt)
        .diff(dayjs.utc(this._startedAt), "minute");
      this.log(`Finished import in ${duration} minutes!!!`);

      await EventGrid.publish(TASKS_IMPORTER_FINISHED_EVENT, {
        subject: this._taskId,
        data: {
          taskId: this._taskId
        }
      });
    } catch (e) {
      const error = new ServiceError(
        {
          name: ServiceError.types.IMPORTER_ERROR,
          cause: e,
          info: {
            critical: true,
            ...this.props
          }
        },
        "Failed to execute importer"
      );
      Log.exception(error);
      // Если есть экземпляр класса
      this._status = STATUS_ERROR;
      this._error = error.json;
      await this.save();
      // Публикуем событие - ошибка
      await EventGrid.publish(ERROR_IMPORTER_ERROR_EVENT, {
        subject: this._taskId,
        data: {
          taskId: this._taskId,
          error: error.json
        }
      });
    }
  }

  get state() {
    return {
      PartitionKey: this._PartitionKey,
      RowKey: this._taskId,
      taskId: this._taskId,
      exchange: this._exchange,
      asset: this._asset,
      currency: this._currency,
      timeframes: this._timeframes,
      mode: this._mode,
      limit: this._limit,
      loadTotalDuration: this._loadTotalDuration,
      loadCompletedDuration: this._loadCompletedDuration,
      loadLeftDuration: this._loadLeftDuration,
      loadPercent: this._loadPercent,
      processTotalDuration: this._processTotalDuration,
      processCompletedDuration: this._processCompletedDuration,
      processLeftDuration: this._processLeftDuration,
      processPercent: this._processPercent,
      dateFrom: this._dateFrom,
      dateTo: this._dateTo,
      settings: this._settings,
      status: this._status,
      error: this._error,
      startedAt: this._startedAt,
      endedAt: this._endedAt,
      metadata: this._metadata
    };
  }

  async save() {
    try {
      await saveImporterState(this.state);
    } catch (e) {
      throw new ServiceError(
        {
          name: ServiceError.types.IMPORTER_SAVE_STATE_ERROR,
          cause: e,
          info: {
            ...this.props
          }
        },
        `Failed to save importer state`
      );
    }
  }
}

export default Importer;
